<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CPU Scheduling Simulator</title>
  <style>
    body {
      background-image: url('C:/Users/DELL/Pictures/Screenshots/Screenshot 2025-04-15 220814.png');
      background-size: cover; /* Cover the entire viewport */
      background-position: center; /* Center the image */
      color: #e0e0e0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      background-color: #0e0e0e;
      color: #e0e0e0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
    }
    h1, h2, h3 {
      text-align: center;
      color: #b76df1;
    }
    .tabs {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    .tab {
      margin: 5px;
      padding: 10px 20px;
      background-color: #b76df1;
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .tab:hover {
      background-color: #b76df1;
    }
    .tab-content {
      display: none;
      margin-top: 20px;
    }
    .active {
      display: block;
    }
    label, select, input, button {
      display: block;
      margin: 10px auto;
      padding: 10px;
      border: none;
      border-radius: 5px;
      text-align: center;
      width: 80%;
      max-width: 400px;
      box-shadow: 0 0 10px #b76df1;
    }
    select, input {
      background-color: #1c1c1c;
      color: #fff;
      border: 1px solid  #b76df1;
    }
    button {
      background-color:  #b76df1;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
    }
    button:hover {
      background-color:  #b76df1;
    }
    table, th, td {
      border: 1px solid  #b76df1;
      border-collapse: collapse;
      padding: 8px;
      text-align: center;
    }
    table {
      width: 100%;
      margin-top: 20px;
    }
    th {
      background-color: #34123a;
      color: #fff;
    }
    td {
      background-color: #1e1e1e;
    }
    #gantt {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 20px;
    }
    .gantt-block {
      padding: 10px;
      margin: 3px;
      background-color: #b76df1;
      color: #fff;
      border-radius: 5px;
      min-width: 60px;
      text-align: center;
    }
    .animation {
      animation: fade-in 1.5s;
    }
    @keyframes fade-in {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <h1 style="text-decoration: underline;">CPU Scheduling Simulator</h1>
  <hr>
  <div class="tabs">
    <div class="tab" onclick="showTab('home')">Home</div>
    <div class="tab" onclick="showTab('about')">About</div>
    <div class="tab" onclick="showTab('algorithms')">Algorithms</div>
    <div class="tab" onclick="showTab('simulator')">Simulator</div>
    <div class="tab" onclick="showTab('team')">Team</div>
  </div>
  

  <div id="home" class="tab-content active animation"><br>
    <br><h2 style="text-decoration: underline;">Welcome to CPU Scheduling Simulator</h2>
    <p style="text-align:center;">
      CPU scheduling is an important part of operating system structure that addresses the 
      process of selecting processes out of the ready queue for CPU execution. In a multitasking or
       multiprogramming system, several processes can be waiting for CPU time, and it is the scheduler that 
       decides which process can utilize the CPU next. This is done through a number of CPU scheduling algorithms,
        each with its own method of maximizing performance. The main objective of CPU scheduling is to achieve maximum 
        CPU utilization while keeping parameters like waiting time, turnaround time, and response time to a minimum. Some of 
        the most popular algorithms are First-Come, First-Served (FCFS), Shortest Job First (SJF), Round Robin (RR), 
        and Priority Scheduling. These algorithms are either preemptive or non-preemptive based on whether they support
         interruption of the running process or not. For instance, Round Robin is a preemptive algorithm that allocates a
          fixed time quantum to each process to ensure fairness and responsiveness in time-sharing systems. FCFS is
           non-preemptive and processes the jobs on arrival order, which may cause longer waiting time for short jobs.
            Sophisticated techniques such as Multilevel Feedback Queue Scheduling learn from the process behavior, shifting 
            priorities and queues dynamically in order to enhance system performance. Effective CPU scheduling prevents a process
             from waiting perpetually (starvation avoidance) and also the system from responding rapidly to user input. It has a 
             significant role to play in real-time systems where deadlines need to be met. In general, CPU scheduling has a 
             strong impact on system throughput, efficiency, and user satisfaction, so it is one of the most critical activities 
             of an operating system.

    </p>
    <br>
  
   <br> <button onclick="showTab('simulator')">Start Simulation</button>
  </div>
  <br>
  <div id="about" class="tab-content">
    <h2><u>About CPU Scheduling Algorithm</u></h2>
    <p style="text-align:center;">
      <p style = "text-align:left;">
        <strong><u>Benefits of CPU Scheduling Algorithms</u></strong><br>
  <br>
  
  Enhanced CPU Utilization.<br>
  Prevents the CPU from going idle for long, making the best use of it.<br>
   
  Effective Process Management.<br>
  Effectively manages numerous processes, providing smooth multitasking within the system.<br>
  Decreased Waiting and Turnaround Time.<br>
  Algorithms such as SJF and SRTF reduce average waiting and turnaround times.<br>
  Equal Distribution of Resources<br>
  Algorithms such as Round Robin provide equal CPU time to each process, preventing starvation.<br>
  Particularly in interactive systems, scheduling enhances user experience by reacting promptly to inputs.<br>
  Sophisticated algorithms such as Multilevel Feedback Queue adapt according to process behavior and priorities.<br>
  Priority-based scheduling guarantees critical or high-priority tasks first, which is crucial in real-time systems.<br>
  Scheduling algorithms perform well even when the number of processes increases, making them ideal for contemporary, complex systems.<br>
  </p>
    </p><br><br>
   <strong><u>Disadvantages of CPU Scheduling</strong></u><br><br>
Complex Implementation.<br>
Starvation of Low-Priority Processes.<br>
Difficult to Predict Execution Time.<br>
Overhead in Preemptive Scheduling.<br>
Unfairness to Long Processes.<br>
Time Quantum Selection Issues (in RR),<br>
Waste of Resources in Inefficient Scheduling.<br>
Not Applicable to all Systems.<br>
Advanced algorithms like Multilevel Feedback Queue or Priority Scheduling can be difficult to implement and manage properly due to their dynamic nature.<br>
In some algorithms (like Priority Scheduling), low-priority processes may wait indefinitely if higher-priority processes keep arriving.<br>
Preemptive algorithms (like Round Robin or SRTF) require frequent context switches, which add overhead and reduce CPU efficiency.<br>
Algorithms such as Shortest Job First (SJF) or Shortest Remaining Time First (SRTF) depend on knowing the burst time of processes, which is difficult to estimate exactly.<br>
Certain algorithms prefer short processes, causing long waiting times for big or CPU-intensive processes.<br>
If the time quantum is very small, it causes too much context switching; if the time quantum is large, the advantage of time-sharing is lost.<br>

Poor scheduling can result in inefficient use of resources, longer waiting time, and reduced system capacity.<br>
A scheduling algorithm suitable for interactive systems is not applicable to real-time or batch processing systems.<br>
  </div>

  <div id="algorithms" class="tab-content">
    <h2><u>CPU Scheduling Algorithms</u></h2>
    <ul style="text-align:center; list-style: none; padding: 0;">
      <li><strong>FCFS:</strong> (First-Come, First-Served)</li>

      <li><strong>SJF:</strong> (Shortest Job First (Non-Preemptive))</li>
      <li><strong>SRTF:</strong> (Shortest Remaining Time First (Preemptive))</li>
      <li><strong>Priority:</strong> (With and without Preemption)</li>
      <li><strong>Round Robin:</strong> (Time-slice based scheduling)</li><br>
      <hr>
    </ul>

    <li>
      <Strong>
        <u>The First Come First Serve (FCFS)</u></Strong><br> FCFS algorithm is one of the simplest CPU scheduling algorithms used in operating systems. It is a non-preemptive 
        scheduling algorithm, meaning once a process starts executing, it runs to completion without being interrupted.<br>
        <strong><br>
          <u>Key Features:</u>
        </strong><br>
<strong>Order of Execution:</strong> In FCFS, the processes are executed in the order of their arrival in the ready queue. The first process to arrive will be executed first and so on.<br>

<strong>Non-Preemptive:</strong> Once a process starts execution, it cannot be interrupted until it is completed. The next process in the queue will wait until the current process is finished.<br>

<strong>Easy to Implement:</strong> FCFS is simple to implement since it has little system overhead. The scheduler merely selects the process at the front of the ready queue.<br>
<br>
<Strong><u>Advantages:</u></Strong><br>
<strong>Simplicity:</strong> The algorithm is easy to comprehend and implement.<br>

<strong>No Starvation:</strong> All processes are executed in the sequence they arrive, so no process will wait forever.<br>
<br>
<strong><u>Drawbacks:</u></strong><br>
<strong>Convoy Effect:</strong>When a longer process arrives earlier than a shorter one, it makes the shorter process wait, resulting in ineffective use of the CPU and higher average waiting time.
<br>
<strong>High Average Waiting Time:</strong> Processes with shorter burst times can experience longer waiting times since they need to wait for all the earlier processes to finish.
<br>
<strong>No Priority Handling:</strong> FCFS does not consider the priority or duration of the process, which might result in bad performance for time-critical tasks.
      <br><br><hr><br>
    </li>

    <li>
      <strong><u>The Shortest Job First (SJF)</u></strong><br> SJF non-preemptive scheduling algorithm is a CPU scheduling strategy where the process with the shortest burst time is selected for execution next.
       It is a non-preemptive algorithm, so once a process starts executing, it runs to completion without being interrupted.<br>
       <br>
       <strong><u>Key Features:</u></strong><br>
<strong>Burst Time-Based:</strong> The shortest CPU burst time process is executed first.<br>

<strong>Non-Preemptive:</strong> A process, once it begins execution, will not be interrupted until it completes.<br>

<strong>Optimal for Waiting Time:</strong> Among all non-preemptive algorithms, SJF provides the least average waiting time, hence it is efficient in that regard.
<br><br>
<strong><u>Advantages:</u></strong><br>
<strong>Minimum Average Waiting Time:</strong> SJF provides the optimal average waiting time among non-preemptive algorithms.
<br>
<strong>Efficient for Short Jobs:</strong> Suitable for batch systems where the jobs are of short duration.
<br>
<br>
<strong><u>Drawbacks:</u></strong><br>
<strong>Needs Burst Time Knowledge:</strong> The algorithm requires proper estimation or knowledge of burst time in advance, which is usually not feasible.

<strong>Starvation:</strong> Longer processes never get an opportunity to execute if short jobs continue coming in, resulting in starvation of long tasks.
<br>
<strong>No Preemption:</strong> As it is non-preemptive, a long job may cause the execution of all other shorter jobs arriving after it to be delayed.
<br><br><hr><br><br>
    </li>

    <li>
      <strong><u>The Shortest Remaining Job First (SRJF)</u></strong><br> SRJF also known as Preemptive Shortest Job First (SJF) — is a preemptive CPU scheduling algorithm. It always selects the process with the 
      shortest remaining burst time to execute next, even if a new process arrives with a shorter remaining time.<br>
<br>
      <strong><u>Key Features:</u></strong><br>
<strong>Preemptive Form of SJF:</strong> SRJF is different from SJF (non-preemptive) in that it permits interrupting the ongoing process if a new process with less remaining time comes in.
<br>
<strong>Dynamic Decision Making:</strong> Decisions regarding scheduling are taken at the arrival of each new process.
<br>
<strong>Best Average Waiting Time:</strong> Similar to SJF, SRJF also gives the best average waiting time for a collection of processes.
<br><br>
 <strong><u>Advantages:</u></strong><br>
<strong>Minimizes Average Waiting Time:</strong> Similar to SJF, but more responsive because of preemption.
<br>
<strong>Responsive to Short Jobs:</strong> Short jobs are executed rapidly, enhancing system response.
<br><br>
<strong><u>Disadvantages:</u></strong><br>
<strong>Starvation:</strong> Long processes can suffer if short jobs continue to arrive.
<br>
<strong>Hard to Predict:</strong> Needs good knowledge of the remaining burst times, which is not always feasible.
<br>
<strong>More Overhead:</strong> More context switching because of preemption causes more overhead.
<br><br><hr><br><br>
    </li>
    <li>
    <strong><u>Priority Preemptive Scheduling</u></strong><br> 
    Priority Preemptive Scheduling is a preemptive CPU scheduling algorithm where each process is assigned a priority, and the CPU is always assigned to the process with the highest priority (lower number = higher priority).
     If a new process arrives with a higher priority than the currently running one, it preempts (interrupts) the current process.
    <br><br>
    <strong><u>How It Works?:</u></strong><br>
Each process is assigned a priority value.<br>

CPU is assigned to the process of highest priority.<br>

When a process of higher priority comes in, it interrupts the running process and begins executing.<br>

When the higher priority process completes, CPU is given back to the previously interrupted process.<br><br>

<strong><u>Advantages:</u></strong><br>
<strong>Fast Response for High-Priority Tasks:</strong> Critical or time-sensitive processes receive immediate access to CPU.
<br>
<strong>Better Control:</strong> Best suited for real-time and interactive systems.<br><br>

<strong><u>Disadvantages:</u></strong><br>
<strong>Starvation:</strong> Low-priority jobs can never run if high-priority jobs keep coming.
<br>
<strong>More Context Switching:</strong> More interrupts mean more overhead.
<br>
<strong>Needs Aging Mechanism:</strong> In order to avoid starvation, older jobs can be given higher priority over time (aging).
<br><br><hr><br><br>
     
      
    </li>
<li>
  <strong><u>Priority Non-Preemptive Scheduling</u></strong> <br>
Priority Non-Preemptive Scheduling is a CPU scheduling algorithm in which every process 
is given a priority, and the CPU is assigned to the highest-priority process. When two processes possess equal priority,
 scheduling occurs according to their arrival time (FCFS). In the non-preemptive form, the process once initiated cannot be 
 terminated till completion.<br><br>

<strong><u>How It Works:</u></strong><br>
Each process is assigned a priority (lower number = higher priority, or vice versa by convention).<br>

The scheduler chooses the highest-priority process out of those that have arrived and are ready.<br>

The chosen process executes to completion.<br>

The next highest-priority process is chosen after that.<br><br>

<strong><u>Key Points:</u></strong><br>
Non-preemptive: A process, once started, cannot be interrupted.<br>

Starvation possible: Low-priority processes may wait forever.<br>

Efficient for systems where task priority is more important than responsiveness.<br><br>

<strong><u>Advantages:</u></strong><br>
Easy to use and simple to implement.<br>

When some tasks are more significant than others.<br><br>

<strong><u>Disadvantages:</u></strong><br>
Starvation of low-priority processes.<br>

Inappropriate for interactive systems where quick response is critical.<br>
<br>
<hr><br><br>


</li>
<li>
  <strong><u>Round Robin Algorithm</u></strong> <br>
The Round Robin (RR) scheduling algorithm is one of the easiest and most popular CPU scheduling algorithms in operating systems. It is highly effective in time-sharing systems.
<br><br>
<strong><u>Important Features:</u></strong><br>
<strong>Preemptive Algorithm:</strong> Every process is allocated a predetermined time slice or quantum.
 If a process does not finish the allocated time, it's preempted and moved to the rear of the ready queue.
<br>
<strong>Fairness:</strong> All processes receive an equal amount of the CPU in cyclic order.
<br>
<strong>Efficient for Short Tasks:</strong> It is good for processes having the same burst times.
<br><br>
<strong><u>How it Works:</u></strong><br>
All the processes are kept in a queue (FIFO).<br>

The CPU selects the first process and executes it for the specified time quantum.<br>

If the process completes earlier than the time quantum, it exits the queue.<br>

If not, it's shifted to the end of the queue and the next process is run.<br><br>

<strong><u>Advantages:</u></strong><br>
Avoids starvation.<br>

Easy to implement and simple.<br>

Ideal for interactive systems.<br><br>

<strong><u>Disadvantages:</u></strong><br>
Too small a time quantum → too many context switches (overhead).<br>

Too large a quantum → acts like FCFS (less responsive).<br>

</li>
  </div>

  <div id="simulator" class="tab-content">
    <h2><u>Simulator</u></h2>
    <label for="algorithm">Select Algorithm:</label>
    <select id="algorithm">
      <option value="FCFS">FCFS</option>
      <option value="SJF">SJF (Non-Preemptive)</option>
      <option value="SRTF">SJF (Preemptive)</option>
      <option value="Priority">Priority (Non-Preemptive)</option>
      <option value="PriorityP">Priority (Preemptive)</option>
      <option value="RR">Round Robin</option>
    </select>

    <label for="quantum">Quantum (for RR only):</label>
    <input type="number" id="quantum" value="2" min="1" />

    <label for="numProcesses">Number of Processes:</label>
    <input type="number" id="numProcesses" placeholder="Enter number of processes" min="1" />
    <button onclick="createProcessTable()">Create Process Table</button>

    <h3>Enter Process Details</h3>
    <table id="processTable">
      <thead>
        <tr>
          <th>PID</th>
          <th>Arrival</th>
          <th>Burst</th>
          <th>Priority</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <button onclick="simulate()">Run Simulation</button>

    <div id="gantt"></div>
    <div id="output"></div>
  </div>

  <div id="team" class="tab-content">
    <h2><u>Meet the Team</u></h2>
    <p style="text-align:center;">This simulator is proudly developed by:</p>
    <ul style="text-align:center; list-style: none;">
      <li>Astha Kumari</li>
      <li>Ishita Choudhary</li>
      <li>Sohan Priyadarshi Saho</li>
    </ul>
  </div>
